"""
Audio2Tekst
=======================================

Ten modu≈Ç zawiera implementacjƒô aplikacji Streamlit do transkrypcji
plik√≥w audio i video na tekst oraz generowania ich podsumowa≈Ñ.

üöÄ WERSJA 2.3.0 - CROSS-PLATFORM EDITION üöÄ
- Uniwersalna kompatybilno≈õƒá z Windows, macOS i Linux
- Dodano automatyczne wykrywanie i obs≈Çugƒô r√≥≈ºnych system√≥w operacyjnych
- Poprawiono ≈õcie≈ºki plik√≥w i komendy systemowe dla wszystkich platform
- Ulepszona obs≈Çuga enkodowania i plik√≥w tymczasowych
- Dodano sprawdzanie dostƒôpno≈õci narzƒôdzi systemowych (FFmpeg/FFprobe)
- Zwiƒôkszona stabilno≈õƒá i niezawodno≈õƒá na r√≥≈ºnych ≈õrodowiskach

Autor: Alan Steinbarth (alan.steinbarth@gmail.com)
GitHub: https://github.com/AlanSteinbarth
Data: 29 maja 2025
Wersja: 2.3.0 (Cross-Platform Edition)
"""

# --- Importy systemowe ---
import hashlib
import logging
import re
import math
import tempfile
import os
import shutil
import subprocess
import platform
from pathlib import Path
from typing import Optional
import time
import threading

# --- Importy zewnƒôtrzne ---
import streamlit as st
import openai
from werkzeug.utils import secure_filename
import yt_dlp

# --- Konfiguracja logowania ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Funkcje pomocnicze dla kompatybilno≈õci system√≥w ---
def get_system_info() -> dict:
    """Zwraca informacje o systemie operacyjnym."""
    return {
        'platform': platform.system().lower(),
        'architecture': platform.machine(),
        'python_version': platform.python_version(),
        'is_windows': platform.system().lower() == 'windows',
        'is_macos': platform.system().lower() == 'darwin',
        'is_linux': platform.system().lower() == 'linux'
    }

def find_executable(name: str) -> Optional[str]:
    """Znajduje ≈õcie≈ºkƒô do pliku wykonywalnego w systemie."""
    system_info = get_system_info()
    
    # Na Windows dodaj .exe je≈õli nie ma rozszerzenia
    if system_info['is_windows'] and not name.endswith('.exe'):
        name += '.exe'
    
    # Sprawd≈∫ czy jest dostƒôpny w PATH
    if shutil.which(name):
        return shutil.which(name)
    
    # Sprawd≈∫ typowe lokalizacje
    common_paths = []
    if system_info['is_windows']:
        common_paths = [
            'C:\\ffmpeg\\bin',
            'C:\\Program Files\\ffmpeg\\bin',
            'C:\\Program Files (x86)\\ffmpeg\\bin'
        ]
    elif system_info['is_macos']:
        common_paths = [
            '/usr/local/bin',
            '/opt/homebrew/bin',
            '/usr/bin'
        ]
    else:  # Linux
        common_paths = [
            '/usr/bin',
            '/usr/local/bin',
            '/snap/bin'
        ]
    
    for path in common_paths:
        full_path = Path(path) / name
        if full_path.exists() and full_path.is_file():
            return str(full_path)
    
    return None

def check_dependencies() -> dict:
    """Sprawdza dostƒôpno≈õƒá wymaganych narzƒôdzi systemowych."""
    dependencies = {
        'ffmpeg': find_executable('ffmpeg'),
        'ffprobe': find_executable('ffprobe')
    }
    
    return {
        name: {
            'available': path is not None,
            'path': path
        } for name, path in dependencies.items()
    }

def get_safe_encoding() -> str:
    """Zwraca bezpieczne kodowanie dla systemu."""
    system_info = get_system_info()
    
    if system_info['is_windows']:
        # Windows mo≈ºe u≈ºywaƒá r√≥≈ºnych kodowa≈Ñ
        return 'utf-8-sig'  # BOM dla lepszej kompatybilno≈õci
    else:
        # Unix-like systemy standardowo u≈ºywajƒÖ UTF-8
        return 'utf-8'

# --- Konfiguracja Streamlit ---
st.set_page_config(page_title="Audio2Tekst", layout="wide")

# --- Sprawdzenie zale≈ºno≈õci systemowych ---
system_info = get_system_info()
dependencies = check_dependencies()

st.title('üìº Audio2Tekst üìù')
st.subheader("Przekszta≈Çƒá swoje pliki audio i video (oraz z YouTube) na tekst, a nastƒôpnie zr√≥b z nich zwiƒôz≈Çe podsumowanie")

# Wy≈õwietl informacje o systemie i zale≈ºno≈õciach
with st.expander("‚ÑπÔ∏è Informacje o systemie", expanded=False):
    col1, col2 = st.columns(2)
    with col1:
        st.write("**System:**")
        st.write(f"- Platform: {system_info['platform'].title()}")
        st.write(f"- Architecture: {system_info['architecture']}")
        st.write(f"- Python: {system_info['python_version']}")
    
    with col2:
        st.write("**Zale≈ºno≈õci:**")
        for dep_name, dep_info in dependencies.items():
            status = "‚úÖ" if dep_info['available'] else "‚ùå"
            st.write(f"- {dep_name}: {status}")
            if dep_info['available']:
                st.write(f"  üìÅ {dep_info['path']}")
    
    st.write("---")
    st.write("**üìã Przetwarzanie d≈Çugich tekst√≥w:**")
    st.write("W przypadku bardzo d≈Çugich transkrypcji (>8000 znak√≥w) tekst jest automatycznie dzielony na fragmenty. Ka≈ºdy fragment jest podsumowywany osobno a na ko≈Ñcu generowane jest finalne podsumowanie ca≈Ço≈õci. RozwiƒÖzuje to ograniczenia OpenAI zwiƒÖzane z d≈Çugo≈õciƒÖ promptu.")

# Sprawd≈∫ czy wszystkie zale≈ºno≈õci sƒÖ dostƒôpne
missing_deps = [name for name, info in dependencies.items() if not info['available']]
if missing_deps:
    st.error(f"‚ö†Ô∏è BrakujƒÖce zale≈ºno≈õci: {', '.join(missing_deps)}")
    st.error("Zainstaluj FFmpeg aby kontynuowaƒá. Zobacz instrukcje instalacji w README.md")
    st.stop()

# --- Konfiguracja OpenAI ---
api_key = st.sidebar.text_input("Podaj sw√≥j OpenAI API Key", type="password")
if not api_key:
    st.stop()
client = openai.OpenAI(api_key=api_key)

# --- Sta≈Çe i konfiguracja ≈õcie≈ºek ---
BASE_DIR = Path("uploads")
for folder in ("originals", "transcripts", "summaries"):
    (BASE_DIR / folder).mkdir(parents=True, exist_ok=True)
ALLOWED_EXT = {".mp3", ".wav", ".m4a", ".mp4", ".mov", ".avi", ".webm"}
MAX_SIZE = 25 * 1024 * 1024  # 25MB
CHUNK_MS = 5 * 60 * 1000     # 5 minutes in ms

# --- Funkcje pomocnicze ---
# UWAGA: To jest ulepszona wersja programu Audio2Tekst
# G≈Ç√≥wne usprawnienia w wersji 2.3.0:
# ‚úÖ Uniwersalna kompatybilno≈õƒá z Windows, macOS i Linux
# ‚úÖ Automatyczne wykrywanie platformy i dostosowanie komend
# ‚úÖ Poprawiona obs≈Çuga ≈õcie≈ºek plik√≥w i enkodowania
# ‚úÖ Dodano sprawdzanie dostƒôpno≈õci narzƒôdzi systemowych
# ‚úÖ Ulepszona obs≈Çuga plik√≥w tymczasowych
# ‚úÖ Zwiƒôkszona stabilno≈õƒá na r√≥≈ºnych ≈õrodowiskach

@st.cache_data
def init_paths(data: bytes, ext: str):
    """Inicjalizuje ≈õcie≈ºki dla plik√≥w na podstawie zawarto≈õci."""
    uid = hashlib.md5(data).hexdigest()
    orig = BASE_DIR / "originals" / f"{uid}{ext}"
    tr = BASE_DIR / "transcripts" / f"{uid}.txt"
    sm = BASE_DIR / "summaries" / f"{uid}.txt"
    if not orig.exists():
        orig.write_bytes(data)
    return uid, orig, tr, sm

def validate_youtube_url(url: str) -> bool:
    """Sprawdza czy URL jest prawid≈Çowym adresem YouTube."""
    import re
    youtube_patterns = [
        r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=[\w-]+',
        r'(?:https?://)?(?:www\.)?youtu\.be/[\w-]+',
        r'(?:https?://)?(?:www\.)?youtube\.com/embed/[\w-]+',
        r'(?:https?://)?(?:www\.)?youtube\.com/v/[\w-]+',
        r'(?:https?://)?(?:www\.)?youtube\.com/shorts/[\w-]+',
        r'(?:https?://)?(?:m\.)?youtube\.com/watch\?v=[\w-]+'
    ]
    
    return any(re.match(pattern, url.strip()) for pattern in youtube_patterns)

def download_youtube_audio(url: str):
    """Pobiera audio z filmu YouTube i konwertuje do odpowiedniego formatu."""
    # Walidacja URL przed pr√≥bƒÖ pobrania
    if not validate_youtube_url(url):
        raise ValueError("Nieprawid≈Çowy adres YouTube. Wklej prawid≈Çowy link do filmu YouTube.")
    
    tmpdir = tempfile.mkdtemp(prefix='audio2tekst_yt_')
    
    try:
        # U≈ºyj bezpiecznych ≈õcie≈ºek dla r√≥≈ºnych system√≥w
        output_template = str(Path(tmpdir) / '%(id)s.%(ext)s')
        
        opts = {
            'format': 'bestaudio[ext=webm]/bestaudio',
            'outtmpl': output_template,
            'quiet': True,
            'noplaylist': True,
            'extractaudio': True,
            'audioformat': 'webm',
            'prefer_ffmpeg': True
        }
        
        with yt_dlp.YoutubeDL(opts) as ydl:
            ydl.download([url])
        
        # Znajd≈∫ pobrany plik
        for f in Path(tmpdir).iterdir():
            if f.suffix.lower() in ALLOWED_EXT and f.is_file():
                data = f.read_bytes()
                return data, f.suffix.lower()
        
        raise FileNotFoundError("Nie znaleziono pliku audio z YouTube")
    
    except ValueError as e:
        # B≈Çƒôdy walidacji URL - przeka≈º dalej bez modyfikacji
        raise e
    except Exception as e:
        error_msg = str(e).lower()
        
        # Obs≈Çuga specyficznych b≈Çƒôd√≥w yt-dlp
        if "is not a valid url" in error_msg or "invalid url" in error_msg:
            raise ValueError("Nieprawid≈Çowy adres YouTube. Wklej prawid≈Çowy link do filmu YouTube.")
        elif "video unavailable" in error_msg or "private video" in error_msg:
            raise RuntimeError("Film jest niedostƒôpny lub prywatny. Spr√≥buj inny film YouTube.")
        elif "sign in" in error_msg or "age restricted" in error_msg:
            raise RuntimeError("Film wymaga logowania lub jest ograniczony wiekowo. Spr√≥buj inny film YouTube.")
        elif "copyright" in error_msg or "blocked" in error_msg:
            raise RuntimeError("Film jest zablokowany lub ma ograniczenia autorskie. Spr√≥buj inny film YouTube.")
        elif "network" in error_msg or "connection" in error_msg:
            raise RuntimeError("B≈ÇƒÖd po≈ÇƒÖczenia z YouTube. Sprawd≈∫ po≈ÇƒÖczenie internetowe i spr√≥buj ponownie.")
        else:
            logger.error(f"B≈ÇƒÖd podczas pobierania z YouTube: {str(e)}")
            raise RuntimeError("WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania z YouTube. Sprawd≈∫ link i spr√≥buj ponownie.")
    
    finally:
        # Bezpieczne usuniƒôcie tymczasowego katalogu
        try:
            shutil.rmtree(tmpdir)
        except Exception as e:
            logger.warning(f"Nie uda≈Ço siƒô usunƒÖƒá tymczasowego katalogu: {e}")

@st.cache_data
def get_duration(path: Path) -> float:
    """Zwraca d≈Çugo≈õƒá pliku audio/video w sekundach."""
    # Sprawd≈∫ dostƒôpno≈õƒá ffprobe
    deps = check_dependencies()
    if not deps['ffprobe']['available']:
        raise RuntimeError("FFprobe nie jest dostƒôpne w systemie. Zainstaluj FFmpeg.")
    
    ffprobe_path = deps['ffprobe']['path']
    cmd = [
        ffprobe_path, '-v', 'error',
        '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(path)
    ]
    
    try:
        result = subprocess.run(
            cmd, 
            capture_output=True, 
            text=True, 
            timeout=30,  # timeout dla bezpiecze≈Ñstwa
            check=True
        )
        return float(result.stdout.strip())
    except subprocess.TimeoutExpired:
        raise RuntimeError("Przekroczono czas oczekiwania na analizƒô pliku")
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"B≈ÇƒÖd podczas analizy pliku: {e}")
    except ValueError as e:
        raise RuntimeError(f"Nie mo≈ºna odczytaƒá d≈Çugo≈õci pliku: {e}")

@st.cache_data
def split_audio(path: Path):
    """Dzieli d≈Çugie pliki audio na mniejsze czƒô≈õci do przetworzenia."""    # Sprawd≈∫ dostƒôpno≈õƒá ffmpeg
    deps = check_dependencies()
    if not deps['ffmpeg']['available']:
        raise RuntimeError("FFmpeg nie jest dostƒôpne w systemie. Zainstaluj FFmpeg.")
    ffmpeg_path = deps['ffmpeg']['path']
    duration = get_duration(path)
    seg_sec = CHUNK_MS / 1000
    parts = []
    
    for i in range(math.ceil(duration / seg_sec)):
        start = i * seg_sec
        length = seg_sec if (start + seg_sec) <= duration else (duration - start)
        
        # Utw√≥rz tymczasowy plik w spos√≥b bezpieczny dla wszystkich platform
        fd, tmp = tempfile.mkstemp(suffix=path.suffix, prefix='audio2tekst_')
        os.close(fd)
        tmp_path = Path(tmp)
        
        cmd = [
            ffmpeg_path, '-y', '-i', str(path),
            '-ss', str(start), '-t', str(length),
            '-c', 'copy', str(tmp_path)
        ]
        
        try:
            subprocess.run(
                cmd, 
                stdout=subprocess.DEVNULL, 
                stderr=subprocess.PIPE,
                timeout=300,  # 5 minut timeout
                check=True,
                text=True
            )
            parts.append(tmp_path)
        except subprocess.TimeoutExpired:
            if tmp_path.exists():
                tmp_path.unlink()
            raise RuntimeError(f"Przekroczono czas oczekiwania podczas dzielenia pliku (segment {i+1})")
        except subprocess.CalledProcessError as e:
            if tmp_path.exists():
                tmp_path.unlink()
            logger.error(f"FFmpeg error: {e.stderr}")
            raise RuntimeError(f"B≈ÇƒÖd podczas dzielenia pliku (segment {i+1}): {e}")
    
    return parts

@st.cache_data
def clean_transcript(text: str) -> str:
    """Czy≈õci transkrypcjƒô z typowych artefakt√≥w mowy."""
    text = re.sub(r"\b(?:em|yhm|um|uh|a{2,}|y{2,})\b", "", text, flags=re.IGNORECASE)
    text = re.sub(r"\s+", " ", text)
    return text.strip()

def transcribe_chunks(chunks, _client):
    """Transkrybuje podzielone fragmenty audio na tekst u≈ºywajƒÖc OpenAI API."""
    texts = []
    long_transcription_msg = "Plik audio poddawany transkrypcji jest bardzo du≈ºy. Potrzebujƒô wiƒôcej czasu. Cierpliwo≈õci..."
    show_long_msg = [False]
    def delayed_info():
        time.sleep(10)
        show_long_msg[0] = True
        st.info(long_transcription_msg)
    thread = threading.Thread(target=delayed_info)
    thread.start()
    with st.spinner("Transkrypcja w toku..."):
        for c in chunks:
            try:
                if c.stat().st_size <= MAX_SIZE:
                    with open(c, 'rb') as f:
                        res = _client.audio.transcriptions.create(
                            model='whisper-1',
                            file=f,
                            language='pl',
                            response_format='text'
                        )
                        texts.append(clean_transcript(str(res)))
                else:
                    logger.warning(f"Plik {c} przekracza maksymalny rozmiar {MAX_SIZE} bajt√≥w")
            except Exception as e:
                logger.error(f"B≈ÇƒÖd podczas transkrypcji fragmentu {c}: {str(e)}")
            finally:
                # Bezpieczne usuniƒôcie pliku tymczasowego
                try:
                    if c.exists():
                        c.unlink()
                except Exception as e:
                    logger.warning(f"Nie uda≈Ço siƒô usunƒÖƒá pliku tymczasowego {c}: {e}")
    return "\n".join(texts)

def summarize(text: str, _client):
    """Generuje temat i podsumowanie z transkrypcji, dzielƒÖc d≈Çugi tekst na fragmenty."""
    log_path = Path("logs/summary_errors.log")
    log_path.parent.mkdir(parents=True, exist_ok=True)
    # Usuniƒôto komunikat o d≈Çugim tek≈õcie
    logger.info(f"Rozpoczynam summarize() - d≈Çugo≈õƒá tekstu: {len(text)} znak√≥w")
    try:
        MAX_CHUNK = 8000  # znak√≥w na fragment (bezpieczny limit)
        if len(text) > MAX_CHUNK:
            logger.info("Tekst jest d≈Çugi - dzielƒô na fragmenty")
            chunks = [text[i:i+MAX_CHUNK] for i in range(0, len(text), MAX_CHUNK)]
            logger.info(f"Podzielono na {len(chunks)} fragment√≥w")
            partial_summaries = []
            for idx, chunk in enumerate(chunks):
                logger.info(f"Przetwarzam fragment {idx+1}/{len(chunks)}")
                with st.spinner(f"Podsumowywanie fragmentu {idx+1}/{len(chunks)}..."):
                    try:
                        prompt = f"Podaj temat w jednym zdaniu i podsumowanie 3-5 zdaniami (fragment {idx+1}/{len(chunks)}):\n" + chunk
                        completion = _client.chat.completions.create(
                            model='gpt-3.5-turbo',
                            messages=[{'role': 'user', 'content': prompt}],
                            max_tokens=300
                        )
                        if completion and completion.choices and completion.choices[0].message:
                            content = completion.choices[0].message.content
                            partial_summaries.append(content)
                        else:
                            raise Exception("Brak odpowiedzi z modelu OpenAI")
                    except Exception as e:
                        msg = f"B≈ÇƒÖd fragmentu {idx+1}: {e}\n"
                        logger.error(msg)
                        with open(log_path, "a", encoding="utf-8") as f:
                            f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} {msg}")
                        st.error(f"B≈ÇƒÖd podczas podsumowywania fragmentu {idx+1}: {e}")
                        return "B≈ÇƒÖd podczas podsumowywania fragmentu", str(e)
            logger.info(f"Zebra≈Çem {len(partial_summaries)} czƒô≈õciowych podsumowa≈Ñ")
            if not partial_summaries:
                st.error("Nie uda≈Ço siƒô wygenerowaƒá ≈ºadnego podsumowania fragment√≥w. Spr√≥buj ponownie lub sprawd≈∫ logi.")
                logger.error("Brak partial_summaries - nie mo≈ºna wygenerowaƒá ko≈Ñcowego podsumowania.")
                return "Nie uda≈Ço siƒô wygenerowaƒá podsumowania", "Brak podsumowa≈Ñ fragment√≥w."
            with st.spinner("Tworzenie ko≈Ñcowego podsumowania..."):
                try:
                    final_prompt = "Oto podsumowania fragment√≥w d≈Çugiego tekstu. Na ich podstawie podaj jeden temat i jedno podsumowanie ca≈Ço≈õci (3-5 zda≈Ñ):\n" + "\n".join(partial_summaries)
                    logger.info(f"Prompt do modelu (final): {final_prompt[:200]}...")
                    completion = _client.chat.completions.create(
                        model='gpt-3.5-turbo',
                        messages=[{'role': 'user', 'content': final_prompt}],
                        max_tokens=300
                    )
                    if completion and completion.choices and completion.choices[0].message:
                        content = completion.choices[0].message.content
                        logger.info(f"Odpowied≈∫ modelu (final): {content[:200]}...")
                        lines = content.splitlines() if content else []
                        topic = lines[0] if lines else 'Nie uda≈Ço siƒô wygenerowaƒá tematu'
                        summary = ' '.join(lines[1:]) if len(lines) > 1 else 'Nie uda≈Ço siƒô wygenerowaƒá podsumowania'
                        logger.info(f"Zwracam: topic='{topic[:50]}...', summary='{summary[:50]}...'")
                        return topic, summary
                    else:
                        logger.error("Brak odpowiedzi z modelu OpenAI (final)")
                        raise Exception("Brak odpowiedzi z modelu OpenAI (final)")
                except Exception as e:
                    msg = f"B≈ÇƒÖd ko≈Ñcowego podsumowania: {e}\n"
                    logger.error(msg)
                    with open(log_path, "a", encoding="utf-8") as f:
                        f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} {msg}")
                    st.error(f"B≈ÇƒÖd podczas generowania ko≈Ñcowego podsumowania: {e}")
                    return "B≈ÇƒÖd podczas generowania ko≈Ñcowego podsumowania", str(e)
        else:
            logger.info("Tekst jest kr√≥tki - bezpo≈õrednie podsumowanie")
            with st.spinner("Podsumowywanie tekstu..."):
                try:
                    prompt = "Podaj temat w jednym zdaniu i podsumowanie 3-5 zdaniami:\n" + text
                    completion = _client.chat.completions.create(
                        model='gpt-3.5-turbo',
                        messages=[{'role': 'user', 'content': prompt}],
                        max_tokens=300
                    )
                    if completion and completion.choices and completion.choices[0].message:
                        content = completion.choices[0].message.content
                        logger.info(f"Otrzymano kr√≥tkie podsumowanie: {content[:100]}...")
                        lines = content.splitlines() if content else []
                        topic = lines[0] if lines else 'Nie uda≈Ço siƒô wygenerowaƒá tematu'
                        summary = ' '.join(lines[1:]) if len(lines) > 1 else 'Nie uda≈Ço siƒô wygenerowaƒá podsumowania'
                        logger.info(f"Zwracam: topic='{topic[:50]}...', summary='{summary[:50]}...'")
                        return topic, summary
                    else:
                        raise Exception("Brak odpowiedzi z modelu OpenAI (kr√≥tki tekst)")
                except Exception as e:
                    msg = f"B≈ÇƒÖd podsumowania kr√≥tkiego tekstu: {e}\n"
                    logger.error(msg)
                    with open(log_path, "a", encoding="utf-8") as f:
                        f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} {msg}")
                    st.error(f"B≈ÇƒÖd podczas podsumowywania tekstu: {e}")
                    return "B≈ÇƒÖd podczas podsumowywania tekstu", str(e)
    except Exception as e:
        # Obs≈Çuga b≈Çƒôdu braku ≈õrodk√≥w/quota w OpenAI
        if 'insufficient_quota' in str(e).lower() or 'you exceeded your current quota' in str(e).lower() or 'error code: 429' in str(e).lower():
            st.error("Brak ≈õrodk√≥w lub limitu na koncie OpenAI. Sprawd≈∫ sw√≥j plan i limity na https://platform.openai.com/account/billing.")
            logger.error(f"B≈ÇƒÖd quota (429/insufficient_quota): {e}")
            return "Brak ≈õrodk√≥w na koncie OpenAI", str(e)
        msg = f"B≈ÇƒÖd og√≥lny podsumowania: {e}\n"
        logger.error(msg)
        with open(log_path, "a", encoding="utf-8") as f:
            f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} {msg}")
        st.error(f"B≈ÇƒÖd og√≥lny podczas podsumowywania: {e}")
        return "B≈ÇƒÖd og√≥lny podczas podsumowywania", str(e)
    
    return "Nie uda≈Ço siƒô wygenerowaƒá podsumowania", "Spr√≥buj ponownie lub skontaktuj siƒô z administratorem"

# --- Interfejs u≈ºytkownika ---
src = st.sidebar.radio('Wybierz ≈∫r√≥d≈Ço audio:', ['Plik lokalny', 'YouTube'])

# Inicjalizacja zmiennych
data, ext = None, None
error_message = None

# Flaga do komunikatu o pobraniu audio z YouTube
if 'yt_success' not in st.session_state:
    st.session_state['yt_success'] = False
if 'yt_data' not in st.session_state:
    st.session_state['yt_data'] = None
if 'yt_ext' not in st.session_state:
    st.session_state['yt_ext'] = None

if src == 'YouTube':
    url = st.sidebar.text_input('Wklej adres www z YouTube:')
    # --- RESET STANU PO ZMIANIE URL ---
    prev_url = st.session_state.get('yt_prev_url', None)
    if url and url != prev_url:
        # Usu≈Ñ stare klucze sesji zwiƒÖzane z poprzedniƒÖ transkrypcjƒÖ/podsumowaniem
        keys_to_remove = []
        for k in list(st.session_state.keys()):
            if isinstance(k, str) and (
                k.startswith('done_') or k.startswith('topic_') or k.startswith('summary_')
                or k.startswith('yt_')
            ):
                keys_to_remove.append(k)
        for k in keys_to_remove:
            del st.session_state[k]
        # Usu≈Ñ pliki powiƒÖzane z poprzednim UID (je≈õli istnieje)
        prev_uid = st.session_state.get('yt_prev_uid', None)
        if prev_uid:
            for folder in (BASE_DIR / 'originals', BASE_DIR / 'transcripts', BASE_DIR / 'summaries'):
                for ext in ('.mp3', '.wav', '.m4a', '.mp4', '.mov', '.avi', '.webm', '.txt'):
                    f = folder / f"{prev_uid}{ext}"
                    if f.exists():
                        try:
                            f.unlink()
                        except Exception as e:
                            logger.warning(f'Nie uda≈Ço siƒô usunƒÖƒá pliku {f}: {e}')
        # Resetuj flagi yt
        st.session_state['yt_success'] = False
        st.session_state['yt_data'] = None
        st.session_state['yt_ext'] = None
        st.session_state['yt_prev_uid'] = None
        st.session_state['yt_prev_url'] = url
    # --- KONIEC RESETU ---
    # Je≈õli ju≈º pobrano audio, przypisz z sesji
    if st.session_state.get('yt_success') and st.session_state.get('yt_data') and st.session_state.get('yt_ext'):
        data = st.session_state['yt_data']
        ext = st.session_state['yt_ext']
        st.success("Pomy≈õlnie pobrano audio z YouTube!")
    elif url:
        try:
            with st.spinner("Pobieranie audio z YouTube..."):
                data, ext = download_youtube_audio(url)
                if not data or not isinstance(data, bytes):
                    raise RuntimeError("Nie uda≈Ço siƒô pobraƒá pliku audio z YouTube lub plik jest uszkodzony.")
                st.session_state['yt_success'] = True
                st.session_state['yt_data'] = data
                st.session_state['yt_ext'] = ext
                # Zapisz UID do p√≥≈∫niejszego czyszczenia
                uid, _, _, _ = init_paths(data, ext)
                st.session_state['yt_prev_uid'] = uid
                st.session_state['yt_prev_url'] = url
                st.success("Pomy≈õlnie pobrano audio z YouTube!")
        except ValueError as e:
            st.warning(f"‚ö†Ô∏è {str(e)}")
            st.session_state['yt_success'] = False
            st.session_state['yt_data'] = None
            st.session_state['yt_ext'] = None
            st.stop()
        except RuntimeError as e:
            st.error(f"‚ùå {str(e)}")
            st.session_state['yt_success'] = False
            st.session_state['yt_data'] = None
            st.session_state['yt_ext'] = None
            st.stop()
        except Exception as e:
            st.error(f"‚ùå WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd: {str(e)}")
            logger.error(f"Nieoczekiwany b≈ÇƒÖd podczas pobierania z YouTube: {str(e)}")
            st.session_state['yt_success'] = False
            st.session_state['yt_data'] = None
            st.session_state['yt_ext'] = None
            st.stop()
        # Po pobraniu przypisz do lokalnych zmiennych
        data = st.session_state['yt_data']
        ext = st.session_state['yt_ext']
    else:
        st.session_state['yt_success'] = False
        st.session_state['yt_data'] = None
        st.session_state['yt_ext'] = None
        st.stop()
else:
    up = st.sidebar.file_uploader('Wybierz plik', type=[e.strip('.') for e in ALLOWED_EXT])
    if up:
        data, ext = up.read(), Path(secure_filename(up.name)).suffix.lower()
    else:
        st.stop()

# Sprawd≈∫ czy mamy dane do przetworzenia
if data is None or ext is None:
    st.stop()

# --- Przetwarzanie pliku ---
uid, orig, tr, sm = init_paths(data, ext)
st.audio(orig.read_bytes(), format=ext.lstrip('.'))
# Przycisk pobierania audio (zawsze pod odtwarzaczem)
# Je≈õli oryginalny plik to .mp4/.webm/.mov/.avi, zaproponuj pobranie jako mp3
if ext in ['.mp3', '.wav', '.m4a']:
    st.download_button('Pobierz audio', orig.read_bytes(), file_name=f'{uid}{ext}')
else:
    # Konwersja do mp3 na ≈ºƒÖdanie
    mp3_path = orig.with_suffix('.mp3')
    if not mp3_path.exists():
        deps = check_dependencies()
        if not deps['ffmpeg']['available']:
            st.warning('FFmpeg nie jest dostƒôpny ‚Äì nie mo≈ºna przekonwertowaƒá do MP3.')
        else:
            ffmpeg_path = deps['ffmpeg']['path']
            cmd = [ffmpeg_path, '-y', '-i', str(orig), str(mp3_path)]
            try:
                subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
            except Exception as e:
                st.warning(f'B≈ÇƒÖd konwersji do MP3: {e}')
    if mp3_path.exists():
        st.download_button('Pobierz audio (MP3)', mp3_path.read_bytes(), file_name=f'{uid}.mp3')
    else:
        st.download_button('Pobierz audio (orygina≈Ç)', orig.read_bytes(), file_name=f'{uid}{ext}')

# --- Stan sesji ---
done_key = f"done_{uid}"
topic_key = f"topic_{uid}"
sum_key = f"summary_{uid}"
for key, default in [(done_key, False), (topic_key, ''), (sum_key, '')]:
    if key not in st.session_state:
        st.session_state[key] = default

# --- Transkrypcja ---
transcript_exists = tr.exists() and tr.stat().st_size > 0
if st.button('Transkrybuj') and not st.session_state[done_key]:
    # dzielenie i transkrypcja
    chunks = split_audio(orig)
    text = transcribe_chunks(chunks, client)
    encoding = get_safe_encoding()
    tr.write_text(text, encoding=encoding)
    st.session_state[done_key] = True
    st.session_state[topic_key] = ''
    st.session_state[sum_key] = ''
    # NIE u≈ºywaj st.experimental_rerun() - po prostu UI przejdzie dalej w kolejnym renderze

# --- UI po transkrypcji ---
if st.session_state[done_key] or transcript_exists:
    encoding = get_safe_encoding()
    transcript = tr.read_text(encoding=encoding) if tr.exists() else ''
    st.subheader('Transkrypt:')
    st.text_area('Transkrypcja', transcript, height=300)
    # Najpierw przycisk pobierania transkryptu
    st.download_button('Pobierz transkrypt', transcript, file_name=f'{uid}_transkrypt.txt')
    # Nastƒôpnie przycisk podsumowania
    if st.button('Podsumuj'):
        topic, summary = summarize(transcript, client)
        st.session_state[topic_key] = topic
        st.session_state[sum_key] = summary
    # Wy≈õwietl podsumowanie je≈õli istnieje
    if st.session_state[topic_key] or st.session_state[sum_key]:
        st.subheader('Temat:')
        st.write(st.session_state[topic_key])
        st.subheader('Podsumowanie:')
        st.write(st.session_state[sum_key])
        # Przycisk pobierania podsumowania
        st.download_button('Pobierz podsumowanie', st.session_state[sum_key], file_name=f'{uid}_podsumowanie.txt')
